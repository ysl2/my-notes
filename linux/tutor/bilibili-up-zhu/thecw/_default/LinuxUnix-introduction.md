# Linux/Unix 入门指南

开源“操作系统”，万物皆文件

manjaro Linux->由 arch Linux 产生

目录结构：
bin：可执行文件，也就是程序存放的地方。bin -> binary 二进制
boot：启动系统，不要乱动
dev：硬件
etc：该文件夹下所有文件都需要管理员权限进行更改，全局的，所有用户都会受到影响
home：用户的家目录，类似 windows 的 MyDocuments 文件夹
如果多个用户，只会看到目前登录用户的文件夹，不会看到其他用户的文件夹
mnt：mount，挂载，和 U 盘相关
proc：所有的进程文件。文件并不一定是真正的写在了我的硬盘下，只是以文件的形式表现出来，然后你可以做更改
root：root 用户的家目录，相当于 home 里面有一个文件夹，只不过管理员的家目录直接放在根目录下了
srv：存放服务文件，同样也是不一定真的存放在了硬盘，只是以文件的形式表现出来
sys：系统文件夹，关于系统的可更改的东西（屏幕亮度等）
tmp：临时文件夹，存放临时文件。如果系统没给你删，可以你自己手动删
usr：linux 不需要 usr 文件夹来运行，这个文件夹一般都是你存放了什么软件，不用深究
var：variable，adj.可变的，指的是 unix 自己也不知道会变得多大，它觉得可能会变得越来越大，里面有 cache 文件夹，存放缓存，没事儿看看，不需要就清掉

使用：
ubuntu centos 等

命令：
pwd：当前在哪个目录。注意：在哪个目录，指令会在当前目录执行操作
ls：列出文件夹、文件等。ls 不会列出你的隐藏文件。
显示隐藏文件的话，用 ls -a，可以显示所有文件，包括以点（.）开头的文件
unix 下认为所有以点开头的文件是隐藏文件。隐藏文件不是坏的文件。
ls -l：use a long listing format 以列表的形式显示出来
ls -la，或者 ls -al 都行，同样效果，就是结合上面两个，以列表的形式显示所有文件
man：全称是 menu，查看一个命令的使用方法。比如 man ls
执行之后出来的文档会非常简单易懂，仔细看看就行。
如何把当前我的执行命令的目录转到别的，目录下：
cd：转移到别的目录
输入 pwd：显示我的当前目录
例如我想到我的根目录：cd /
或者 cd bin 之类的
cd .. ：回到上一级文件夹
cd ~/Desktop :可以直接回到我的用户目录。效果等同于：cd /home/david
自动补全：按 Tab 键

文件相关命令：
mkdir：新建文件夹。 例如：mkdir new_folder
但是新建完之后，你还是在原先的目录下的。如果想进入，可以用 cd new_folder/
touch：新建文件。比如 touch new_file，然后可以用 ls -l 查看文件列表
nano：文字编辑器。如果想编辑刚才这个文件，用 nano new_file
vim：也是一个文字编辑器。vim new_file
cat：用 vim 写完之后，保存并退出，可以用 ls -l 查看文件列表。
然后用 cat new_file 把文件内容直接打到终端下
less：less new_file，会在一个新窗口打印文件内容。按 q 退出
mv：移动文件。很多指令，用 man mv 来显示一下命令列表。非常推荐阅读
在这儿只介绍一个：比如我想复制这个文件到桌面：
mv new_file ~/Desktop/ -> mv [要移动的文件] [要移动到的目的地]
[要移动到的目的地]可以是一个文件夹，也可以是一个文件
如果[要移动到的目的地]是一个文件夹，而不是一个文件的话，就不会重命名我想移动的这个文件
如果[要移动到的目的地]是一个文件，那么说明我已经给这个移动后的文件指定了一个文件名，就会执行重命名
这样之后，就把我的这个文件移动到了桌面下
移动指令也可以用于重命名。比如 mv old_file.txt new_file.txt，我没有给路径，第二个参数只是一个单纯的文件
注意此处：这种情况下，会默认是用户当前所在的路径。也就是说，要先 cd 到[要移动的文件]所在的位置
然后就会执行重命名操作。
我现在的路径是 ~/Desktop/new_folder，用 cd ~/Desktop/到上一级文件夹，也就是桌面
或者直接用 cd ..直接回到上一级文件夹
然后我 ls 一下，就能看到我的 new_file
然后我想把我的 new_file 再移动回我的 new_folder 里面，但是这回我想改个名字，我想给他改成 old_file：
用 mv new_file new_folder/old file.txt，此处[要移动到的目的地]是一个文件，所以重命名了
然后我再进入 new_folder，cd new_folder/，用 ls，就能看到我的 old_file.txt
另外，mv 和 cp 都是有更高级的指令的：
比如 mv -i：当覆盖目前已经存在的文件之前，会提示你要不要覆盖
mv -f：强制覆盖，不提示你
cp：copy -> 复制。 cp file.txt file_duplicated.txt 同样遵循上面的规则，第二个参数的位置自动补全了我当前所在文件夹的位置
然后 ls 一下，会发现当前文件夹有两个文件：file.txt 和 file_duplicated.txt
rm：remove -> 删除指令。谨慎使用，不友好，不会像 Windows 那样放在垃圾箱里
比如我想删除，rm file.txt ，回车之后，就真的把文件给删了。可以 ls 一下看看，确实没了。
但是并不是所有东西都是这么简单可以删掉的。用 .. 回到上一层目录，
然后如果我想删掉 new_folder 这个文件夹，rm new_folder ，就会报错：“不能删掉，因为这是一个文件夹”
这时可以查看一下 rm 的说明，可以看到有一个，rm -f，rm -r
-r 指的是 recursive，意思是递归性的、重复性的删除目录和这个目录里面包含的所有的文件
这是一个很危险的指令，如果想删除文件夹的话，就需要用 rm -r 来删掉：rm -r new_folder
但是执行命令之前，要想清楚
